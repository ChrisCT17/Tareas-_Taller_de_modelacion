# -*- coding: utf-8 -*-
"""Tarea11_Equipo11_taller_de_modelacion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tNgsq1UJcIJHPRWxlBIz_lcKF1j-rbo-

# Dependencias
"""

from time import time
import matplotlib.pyplot as plt
import numpy as np

"""# EJERCICIO 1:

1. Implemente el generador lineal congruencial visto en clase.

a) Implemente el generador lineal congruencial, para generar datos ${X_{1},X_{2},...,X_{n}}$ que sean números aleatorios en ${0,1,...,m-1}$. Divídalos entre $m$ para obtener datos ${U_{1},...,U_{n}}$ con densidad uniforme en $(0,1)$. Puede tomar $a=1=c$ y $m=2^{32}-1$.

b) Con tal programa, grafique la serie de datos obtenidos.

c) Haga parejas $(U_{i},U_{j})$ (dividiendo los datos obtenidos a la mitad) y grafique tales coordenadas en el espacio $[0,1]^{2}$. ¿Cómo se ven los datos?


"""

# Inciso a y b
def gcnp(n: int) -> list[float]:
    t = time()
    m = (2 ** 32) - 1
    a = 1
    c = 1
    nums = [ t ]
    for i in range(n):
        nums.append((a * nums[i] + c) % m)
    return [ elemento / m for elemento in nums[1:] ]

valores = gcnp(200)   # genera 100 valores

plt.plot(valores, marker='o')
plt.title("Números generados por gcnp")
plt.xlabel("Índice")
plt.ylabel("Valor")
plt.grid(True)
plt.show()

# Inciso 1c
mitad = len(valores) // 2
U_i = valores[:mitad]
U_j = valores[mitad:]

plt.figure(figsize=(8, 6))
plt.scatter(U_i, U_j, alpha=0.6, s=20)
plt.title("Parejas (U_i, U_j) en el espacio [0,1]²")
plt.xlabel("U_i")
plt.ylabel("U_j")
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.grid(True, alpha=0.3)
plt.axis('equal')
plt.show()

"""Al dividir a la mitad los valores, obtenemos el mismo resultado y la misma gráfica, ya que como son aleatorio, lo único que hacemos es reescalar el comportamiento aleatorio, no estamos alterando esa naturaleza, de otra forma al normalizar no podríamos tener valores aleatorios en el intervalo cerrado de 0 a 1.

#EJERCICIO 2
Estime el valor de π haciendo lo siguiente: Note que el lugar geom´etrico dado
por el sector S := {(x, y) ∈ [0, 1] : x
2 + y
2 ≤ 1} tiene ´area proporcional
a π (calcule cu´anto exactamente). As´ı, la probabilidad p de que un punto
tirado al azar en el cuadrito [0, 1]2
caiga en el sector S es proporcional a π
(calcule calcule cu´anto exactamente). Usando el programa del ejercicio 1 tire
muchos puntos en el cuadrito [0, 1]2 y cuente cu´antos cayeron en el sector S
(los favorables). Estimando p por ˆp, donde ˆp es la proporci´on de los favorables
entre los totales, puede multiplicar por un factor para obtener una estimaci´on
de π. ¿Cu´antos decimales correctos puede estimar con su computadora y en
cu´anto tiempo de m´aquina?

Tomando en consid3rqción el círculo unitario centrado en el origen, al calcular su área obtenemos que es  A = pi*(1)^2 = pi
Ahora, de todo el círculo la única parte que cumple con que sus puntos están formados por x en [0,1] y y en [0,1] son los que perteneces al primer cuadrante, que justamente es una cuarta parte del círculo unitario
Entonces el área del sector circular es S = pi/4

Ahora, pa4a calcular la probabilidad de que un punto tirado al azar caiga dentro del sector S, tomemos una interpretación de la definición de la proba clásica, cambiando casos por área, (área favorabñe entre área total).
Con lo cual al sacar el área de del cuadrado que tiene como lados los intervalos [0,1], basta sacar la norma de un lado, que es la norma de ese intervalo que es 1, por lo que el área del cuadrado es C = 1*1 = 1
P(s) = S / C = (pi/4)/1
P(s) = pi/4
"""

from time import time
m = 2 ** 64

def gcnp(n: int, m: int = m) -> list[float]:
    t = time()
    a = 653
    c = 144
    nums = [ t ]
    for i in range(n-1):
        nums.append((a * nums[i] + c) % m)
    return [ elemento / m for elemento in nums ]
inicio = time()
valores = gcnp(100000000)

X=[]
Y=[]
for i in range(99999999):
  if i%2==0:
     X.append(valores[i])
  else:
     Y.append(valores[i])
Cf=0
for j in range(49999999):
  if X[j]**2+Y[j]**2<=1:
    Cf+=1
fin = time()
print(4*Cf/50000000)
print("Tiempo: ", fin-inicio)

"""Nosotros obtuvimos 3 decimales correcots en un tiempo de 84 segundos

# Ejercicio 3

**3.** Estime el valor de la integral $$I=\int_{0}^{3} e^{\frac{t}{2}}  dt$$.

**a)** Primero genere parejas uniformes $(X,Y)$ que fueron generadas uniformemente en el rectángulo $[0,3] \times [0,M]$, y cuente los casos favorables entre los totales para estimar el área. Aquí $M>0$ es una cota (que debe encontrar) tal que $e^{\frac{t}{2}} \leq M$ en todo el intervalo $[0,3]$. Por otro lado, calcule analíticamente el valor de $I$. Con ello, grafique cómo va convergiendo el estimador al valor verdadero conforme $n$, el número de lanzamientos, crece.

**b)** Ahora se propone otro método para estimar $I$ del inciso anterior. Genere números uniformes $U_{1},...,U_{n}$ en $[0,3]$. Defina la aproximación de $I$ (su estimador) por
$$\tilde{I}:=\frac{1}{n}\sum_{i=1}^{n}f(U_{i}),$$
donde $f(t)=e^{\frac{t}{2}}$. Grafique cómo va convergiendo el estimador conforme $n$, el número de lanzamientos, crece.

**c)** ¿Qué método fue mejor, en términos de converger más rápidamente? ¿Puede dar una intuición de por qué el segundo método funciona?
"""

#incisio a)
def gcnp(n: int) -> list[float]:
    m = (2 ** 32) - 1
    t = time()
    f = 653
    c = 144
    nums = [t]
    for i in range(n-1):
        nums.append((f * nums[i] + c) % m)
    return [elemento / m for elemento in nums]

# Parámetros para montecarlo
a, b = 0, 3
M = np.exp(1.5)
I_exacto = 2 * (np.exp(1.5) - 1)

def g(t):
    return np.exp(t / 2)

def montecarlo_area(n):

    U = gcnp(2 * n)

    # Primera mitad para X, segunda para Y
    X = [u * (b - a) for u in U[:n]]  # Escalar a [0,3]
    Y = [u * M for u in U[n:2*n]]     # Escalar a [0,M]

    # Contar éxitos
    k = 0
    for i in range(n):
        if Y[i] <= g(X[i]):
            k += 1

    area_rect = (b - a) * M
    I_est = (k / n) * area_rect
    return I_est

# Lanzamientos n
ns = np.linspace(100, 50000, 50, dtype=int)
estimaciones = []
for i,n in enumerate(ns):
    estim = montecarlo_area(n)
    estimaciones.append(estim)

print(f"ÚLTIMA ESTIMACIÓN (n={ns[-1]}): {estimaciones[-1]}")
print(f"VALOR EXACTO: {I_exacto}")
print(f"ERROR: {abs(estimaciones[-1] - I_exacto)}")

# Gráfica
plt.figure(figsize=(10, 6))
plt.plot(ns, estimaciones, 'bo-', label='Estimación')
plt.axhline(I_exacto, color='r', linestyle='--', label=f'Valor exacto = {I_exacto:.5f}')
plt.xscale('log')
plt.xlabel('Número de puntos n')
plt.ylabel('Estimación de I')
plt.title('Convergencia hacia el valor exacto')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import math

# Variables
I_real = 2 * (math.exp(1.5) - 1) #Calculamos la integral
f = lambda t: np.exp(t/2)
a, b = 0, 3

# Número máximo de simulaciones
Nmax = 20000

estimadores = []

# Cálculo del estimador conforme crece n
for n in range(1, Nmax + 1):
    U = np.random.uniform(a, b, n)
    I_n = (b - a) * np.mean(f(U))   # estimador de la integral
    estimadores.append(I_n)

plt.plot(estimadores, label="Estimador MC simple")
plt.axhline(I_real, linestyle="--", color="red", label="Valor real")    #Grafica
plt.xlabel("n (número de lanzamientos)")
plt.ylabel("Valor estimado")
plt.title("Convergencia del estimador Monte Carlo")
plt.legend()
plt.grid(True)
plt.show()