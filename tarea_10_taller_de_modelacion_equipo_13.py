# -*- coding: utf-8 -*-
"""Tarea 10_taller_de_modelacion_equipo_13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WeC17swdu5DN8sUqvgOYTfVBwdTKhRQj
"""

import math
import random
from typing import List, Tuple
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Ciudades dadas en el problema
cities = [(1, 2), (2, 7), (3, 4), (4, 1), (4, 6), (5, 3), (6, 5), (7, 5), (9, 9), (10, 1)]
N = len(cities)

# Función de distancia Manhattan
def manhattan_distance(city1: Tuple[int, int], city2: Tuple[int, int]) -> float:
    return abs(city1[0] - city2[0]) + abs(city1[1] - city2[1])

# Calcular costo total de un tour
def tour_cost(tour: List[int]) -> float:
    total_cost = 0.0
    for i in range(N):
        total_cost += manhattan_distance(cities[tour[i]], cities[tour[(i + 1) % N]])
    return total_cost

# Generar vecino mediante operación 2-opt (inversión de segmento)
def generate_neighbor(current: List[int]) -> List[int]:
    neighbor = current.copy()
    i, j = random.sample(range(N), 2)
    if i > j:
        i, j = j, i
    neighbor[i:j+1] = reversed(neighbor[i:j+1])
    return neighbor

# Algoritmo de Enfriamiento Estocástico (Simulated Annealing)
def simulated_annealing(
    T0=30,           # temperatura inicial
    T_min=1e-3,      # temperatura mínima
    alpha=0.95,      # factor de enfriamiento
    iters_per_T=200, # iteraciones por temperatura
    seed=42
):
    random.seed(seed)

    # Solución inicial aleatoria
    current = list(range(N))
    random.shuffle(current)
    E_curr = tour_cost(current)

    best = current[:]
    E_best = E_curr
    T = T0

    hist_best, hist_curr = [], []
    temps = []
    frames = []  # Para animación

    # Bucle principal (criterio de parada: T < T_min)
    iteration = 0
    while T > T_min:
        for _ in range(iters_per_T):
            # Generar vecino
            candidate = generate_neighbor(current)
            E_cand = tour_cost(candidate)
            delta_E = E_cand - E_curr

            # Criterio de aceptación
            if delta_E < 0 or random.random() < math.exp(-delta_E / T):
                current = candidate
                E_curr = E_cand

                # Actualizar mejor solución
                if E_curr < E_best:
                    best = current[:]
                    E_best = E_curr

            # Guardar frame para animación cada 50 iteraciones
            iteration += 1
            if iteration % 50 == 0:
                frames.append((current[:], T, E_curr, iteration))

        # Registrar historial
        hist_best.append(E_best)
        hist_curr.append(E_curr)
        temps.append(T)

        # Enfriar
        T *= alpha

    return best, E_best, hist_best, hist_curr, temps, frames

# Visualización estática del tour
def plot_tour(tour: List[int], title: str = "TSP Tour"):
    fig = plt.figure(figsize=(6, 6))
    xs = [p[0] for p in cities]
    ys = [p[1] for p in cities]
    plt.scatter(xs, ys, s=60)

    # Etiquetar ciudades
    for idx, (x, y) in enumerate(cities):
        plt.text(x + 0.12, y + 0.12, str(idx), fontsize=9)

    # Dibujar tour
    x_tour = [cities[i][0] for i in tour] + [cities[tour[0]][0]]
    y_tour = [cities[i][1] for i in tour] + [cities[tour[0]][1]]
    plt.plot(x_tour, y_tour, linewidth=2, c='orange')

    plt.title(title)
    plt.gca().set_aspect("equal", adjustable="box")
    plt.grid(True, linestyle="--", alpha=0.4)
    plt.xlim(0, 11)
    plt.ylim(0, 10)
    plt.show()

# Configuración para animación
def setup_animation():
    fig = plt.figure(figsize=(6, 6))
    xs = [p[0] for p in cities]
    ys = [p[1] for p in cities]
    plt.scatter(xs, ys, s=60)

    # Etiquetar ciudades
    for idx, (x, y) in enumerate(cities):
        plt.text(x + 0.12, y + 0.12, str(idx), fontsize=9)

    line, = plt.plot([], [], linewidth=2, c='orange')
    plt.title("Simulated Annealing - Evolución del tour")
    plt.gca().set_aspect("equal", adjustable="box")
    plt.grid(True, linestyle="--", alpha=0.4)
    plt.xlim(0, 11)
    plt.ylim(0, 10)
    annot = plt.text(0.02, 0.98, "", transform=plt.gca().transAxes, va="top", ha="left")

    return fig, line, annot

def init_animation():
    line.set_data([], [])
    annot.set_text("")
    return line, annot

def update_animation(frame, line, annot):
    tour, T, cost, itercount = frame
    x = [cities[i][0] for i in tour] + [cities[tour[0]][0]]
    y = [cities[i][1] for i in tour] + [cities[tour[0]][1]]

    line.set_data(x, y)
    annot.set_text(f"Temp: {T:.3f}\nCosto: {cost:.2f}\nIter: {itercount}")

    return line, annot

# Ejecutar el algoritmo
if __name__ == "__main__":


    best_tour, best_cost, hist_best, hist_curr, temps, frames = simulated_annealing()

    print(f"Mejor tour encontrado: {best_tour}")
    print(f"Costo del mejor tour: {best_cost}")

    # Graficar convergencia
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 3, 1)
    plt.plot(hist_best, label='Mejor costo', linewidth=2)
    plt.plot(hist_curr, label='Costo actual', alpha=0.7)
    plt.xlabel('Iteración')
    plt.ylabel('Costo')
    plt.legend()
    plt.title('Convergencia del SA')
    plt.grid(True, linestyle='--', alpha=0.4)

    plt.subplot(1, 3, 2)
    plt.plot(temps, hist_best)
    plt.xlabel('Temperatura')
    plt.ylabel('Mejor costo')
    plt.title('Costo vs Temperatura')
    plt.grid(True, linestyle='--', alpha=0.4)

    plt.subplot(1, 3, 3)
    plt.semilogy(temps)
    plt.xlabel('Iteración')
    plt.ylabel('Temperatura (log)')
    plt.title('Enfriamiento')
    plt.grid(True, linestyle='--', alpha=0.4)

    plt.tight_layout()
    plt.show()

    # Mostrar tour final
    plot_tour(best_tour, f"Simulated Annealing - Mejor tour (Costo: {best_cost:.2f})")

    # Crear animación (opcional)
    print("Creando animación...")
    fig, line, annot = setup_animation()
    anim = FuncAnimation(fig, update_animation, fargs=(line, annot),
                        frames=frames, init_func=init_animation,
                        blit=True, interval=100, repeat=True)

    plt.show()

    # Explicación de hiperparámetros
    print("\n" + "="*50)
    print("EXPLICACIÓN DE HIPERPARÁMETROS:")
    print("="*50)
    print("T0 (ej: 30): muy alta = aceptas muchos empeoramientos (exploras más);")
    print("             muy baja = te 'congelas' pronto.")
    print("alpha (0.95): más cercano a 1 = enfriamiento lento (más intentos totales);")
    print("              más bajo = enfrías rápido (menos exploración).")
    print("iters_per_T (200): más iteraciones por nivel = exploras mejor cada 'temperatura'.")
    print("T_min: demasiado alto = cortas antes; demasiado bajo = tiempo extra con poca ganancia.")
    print("seed: te da reproducibilidad para clase/demos.")