# -*- coding: utf-8 -*-
"""Tarea 8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1asPmUxPU7lqMYe2bTkEayk7nB3ajCmyY

# Algoritmo para resolver el problema
"""

"""
Tarea 8 - Taller de Modelación I
Equipo 13
Integrantes:
 - Cortes Tovar Christopher
 - Jesús Eduardo Urrutia Tovar
 - González Arias Lorelin

Problema de la Trayectoria de Máximo Peso

Este programa calcula la trayectoria que recoge el mayor peso posible
en una grilla n x n con pesos positivos distribuidos de forma exponencial.
Además, realiza simulaciones para analizar el comportamiento de L(n,n)
y estudia la función g(n, alpha) definida en la tarea.
"""

import numpy as np
import matplotlib.pyplot as plt


# -----------------------------------------------------
# 1. Función base: calcular_trayectoria_maxima
# -----------------------------------------------------
def calcular_trayectoria_maxima(n, scale=1.0, rng=None):
    """
    Calcula la trayectoria de máximo peso en una grilla n x n
    con pesos exponenciales y reconstruye el camino óptimo.

    Args:
        n (int): Tamaño de la grilla
        scale (float): Parámetro 'scale' de la distribución exponencial
        rng (np.random.Generator): Generador para reproducibilidad

    Returns:
        L (ndarray): Matriz de pesos máximos acumulados
        camino (ndarray): Matriz de direcciones ('A' o 'D')
        peso_maximo (float): Valor L[n-1, n-1]
        trayectoria (list): Lista de tuplas (i,j) del camino óptimo
        pesos (ndarray): Matriz de pesos generada
    """
    if rng is None:
        rng = np.random.default_rng()

    # Generar pesos aleatorios con distribución exponencial
    pesos = rng.exponential(scale=scale, size=(n, n))

    # Inicializar matrices
    L = np.zeros((n, n))
    camino = np.zeros((n, n), dtype='<U1')  # 'A' (arriba) o 'D' (derecha)

    # Caso base: esquina (0,0)
    L[0, 0] = pesos[0, 0]

    # Llenar primera columna (solo se puede venir de arriba)
    for i in range(1, n):
        L[i, 0] = pesos[i, 0] + L[i - 1, 0]
        camino[i, 0] = 'A'

    # Llenar primera fila (solo se puede venir de la izquierda)
    for j in range(1, n):
        L[0, j] = pesos[0, j] + L[0, j - 1]
        camino[0, j] = 'D'

    # Llenar el resto de la matriz
    for i in range(1, n):
        for j in range(1, n):
            if L[i - 1, j] > L[i, j - 1]:
                L[i, j] = pesos[i, j] + L[i - 1, j]
                camino[i, j] = 'A'
            else:
                L[i, j] = pesos[i, j] + L[i, j - 1]
                camino[i, j] = 'D'

    # Reconstruir la trayectoria óptima
    trayectoria = []
    i, j = n - 1, n - 1
    while i > 0 or j > 0:
        trayectoria.append((i, j))
        if camino[i, j] == 'A':
            i -= 1
        else:
            j -= 1
    trayectoria.append((0, 0))
    trayectoria.reverse()

    return L, camino, L[n - 1, n - 1], trayectoria, pesos


# -----------------------------------------------------
# 2. Inciso (a): promedio de L(n,n) para varios n
# -----------------------------------------------------
def estimar_promedio_L(n, num_corridas=1000, scale=1.0):
    """Repite el experimento varias veces y calcula el promedio de L(n,n)."""
    valores = []
    rng = np.random.default_rng()
    for _ in range(num_corridas):
        _, _, lnn, _, _ = calcular_trayectoria_maxima(n, scale=scale, rng=rng)
        valores.append(lnn)
    return np.mean(valores), np.array(valores)


def experimento_varios_n(n_values, num_corridas=500, scale=1.0):
    """Ejecuta el experimento para varios tamaños de malla."""
    promedios = []
    for n in n_values:
        prom, _ = estimar_promedio_L(n, num_corridas=num_corridas, scale=scale)
        print(f"n = {n}, promedio L(n,n) = {prom:.4f}")
        promedios.append(prom)
    return np.array(promedios)


# -----------------------------------------------------
# 3. Ajuste de f(n) = a*n + b (ajuste lineal)
# -----------------------------------------------------
def ajustar_lineal(n_values, L_prom):
    """Ajusta una función lineal f(n) = a*n + b a los datos simulados."""
    coef = np.polyfit(n_values, L_prom, 1)
    a, b = coef
    return a, b


# -----------------------------------------------------
# 4. Inciso (b): graficar la geodésica vs diagonal identidad
# -----------------------------------------------------
def graficar_trayectoria(trayectoria, n):
    """Muestra la trayectoria óptima y la diagonal identidad."""
    xs = [j for (i, j) in trayectoria]
    ys = [i for (i, j) in trayectoria]

    plt.figure()
    plt.plot(xs, ys, marker='o', label='Geodésica (camino óptimo)')
    plt.plot([0, n - 1], [0, n - 1], '--', label='Diagonal identidad')
    plt.title(f"Trayectoria óptima para n = {n}")
    plt.xlabel("j (columna)")
    plt.ylabel("i (fila)")
    plt.legend()
    plt.grid(True)
    plt.show()


# -----------------------------------------------------
# 5. Inciso (c): cálculo de g(n, alpha)
# -----------------------------------------------------
def calcular_g(n, alpha, a, b, num_corridas=300, scale=1.0):
    """
    Calcula los valores de g(n, alpha) = (L(n,n) - f(n)) / n^alpha
    repitiendo varias simulaciones para un n fijo.
    """
    rng = np.random.default_rng()
    g_vals = []
    f_n = a * n + b
    for _ in range(num_corridas):
        _, _, lnn, _, _ = calcular_trayectoria_maxima(n, scale=scale, rng=rng)
        g_val = (lnn - f_n) / (n ** alpha)
        g_vals.append(g_val)
    return np.array(g_vals)


# -----------------------------------------------------
# 6. Ejecución principal (todo el análisis)
# -----------------------------------------------------
if __name__ == "__main__":
    print("=== Tarea 8: Problema de la Trayectoria de Máximo Peso ===\n")

    # Valores de n para el inciso (a)
    n_values = [10, 20, 30, 40, 50]
    L_prom = experimento_varios_n(n_values, num_corridas=500, scale=1.0)

    # Ajuste lineal f(n) = a*n + b
    a, b = ajustar_lineal(np.array(n_values), L_prom)
    print(f"\nAjuste lineal obtenido: f(n) = {a:.4f} * n + {b:.4f}")

    # Ejemplo de trayectoria (inciso b)
    n_grande = 50
    _, _, lnn, trayectoria, _ = calcular_trayectoria_maxima(n_grande)
    print(f"\nEjemplo de L({n_grande},{n_grande}) = {lnn:.4f}")
    print("Para ver la gráfica de la geodésica, descomenta la línea siguiente:")
    # graficar_trayectoria(trayectoria, n_grande)

    # Inciso (c): prueba de g(n, alpha) para distintos alphas
    alphas = [0.2, 0.3, 0.4, 0.5]
    print("\nValores aproximados de g(n, α) para distintos exponentes:\n")
    for alpha in alphas:
        g_vals = calcular_g(n=50, alpha=alpha, a=a, b=b, num_corridas=200)
        print(f"α = {alpha:.2f} | mediana = {np.median(g_vals):.4f} | "
              f"rango ≈ [{g_vals.min():.4f}, {g_vals.max():.4f}]")

    print("\nSimulación completada correctamente ✅")